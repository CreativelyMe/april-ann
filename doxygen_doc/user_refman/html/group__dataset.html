<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<title>april-ann</title>
<link href="our_doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<div class="tabs"><ul>
<li id="current"><a href="../../user_refman/html/index.html"><span>april-ann (user reference manual)</span></a></li>
<li><a href="../../developer/html/index.html"><span>april-ann (developer manual)</span></a></li>
</ul></div>
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">Dataset</div>  </div>
<div class="ingroups"><a class="el" href="group__basics.html">Basics</a></div></div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Dataset:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__dataset.png" border="0" alt="" usemap="#group____dataset"/>
<map name="group____dataset" id="group____dataset">
<area shape="rect" id="node1" href="group__basics.html" title="Basics" alt="" coords="7,5,68,35"/></map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacedataset"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedataset.html">dataset</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdataset.html">dataset</a></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>


<h3><a class="anchor" id="dataset"></a>Dataset</h3><div class="textblock">Las matrices por sí mismas no son directamente utilizables desde los algoritmos de aprendizaje automático, ya que estos utilizan una abstracción de un conjunto de datos denominada <code>dataset</code> Un <code>dataset</code> responde a los métodos siguientes:<ul>
<li><b>numPatterns</b>, devuelve el número de patrones.</li>
</ul>
<ul>
<li><b>patternSize</b>, devuelve el tamaño máximo de los patrones.</li>
</ul>
<ul>
<li><b>getPattern</b>, recibe un índice numérico (un valor entre 1 y numPatterns) y devuelve un vector (tabla {Lua}) con el índice-ésimo patrón.</li>
</ul>
<ul>
<li><b>putPattern</b>, recibe un índice numérico (un valor entre 1 y {numPatterns}) y un vector de tamaño {patternSize} y modifica el {dataset} para dar cuenta de esta información. No todas las clases {dataset} permiten modificarse, y en tal caso avisan devolviendo 0 en lugar de {patternSize}. {itemize}</li>
</ul>
<h1><a class="anchor" id="dataset_matrix"></a>
dataset.matrix</h1>
<p>La forma más convencional de crear un <code>dataset</code> es a partir de una matriz: </p>
<pre class="fragment">--&gt; recordemos que xor_in es una matriz de 4x2
ds_xor_in = dataset.matrix(xor_in) --&gt; 4 patrones de tamaño 2
--&gt; recordemos que xor_out es una matriz de 4x1
ds_xor_out = dataset.matrix(xor_out) --&gt; 4 patrones de tamaño 1
</pre><p>Cuando creamos un dataset a partir de una matriz de dimensiones $n_1  n_2    n_k$ se crea un dataset con $n_1$ patrones de tamaño $n_2   n_{k}$. Para una matriz de dimensión 2 corresponde con lo esperado de manera intuitiva, mientras que para una matriz tiene una sola dimensión (un vector) se corresponde con el recorrido de todos sus valores, como se aprecia en el siguiente ejemplo, donde además vemos que el método <code>patterns()</code> devuelve un iterador que se puede utlizar en un bucle <code>for:</code> </p>
<pre class="fragment">a = matrix(2, 2, {1,2,3,4})
b = dataset.matrix(a)
for i,j in b:patterns() do print(table.concat(j,",")) end
--&gt; 1,2
--&gt; 3,4
a = matrix(2,2,2,{1,2,3,4,5,6,7,8})
b = dataset.matrix(a)
for i,j in b:patterns() do print(table.concat(j,",")) end
--&gt; 1,2,3,4
--&gt; 5,6,7,8
a = matrix(4,{1,2,3,4})
b = dataset.matrix(a)
for i,j in b:patterns() do print(table.concat(j,",")) end
--&gt; 1
--&gt; 2
--&gt; 3
--&gt; 4
</pre><p>Hasta aquí no se aprecia ninguna ventaja del uso de <code>dataset</code> respecto de las matrices. Vamos a ver que sobre una misma matriz podemos generar varios datasets variando algunos parámetros que, hasta el momento, se han tomado por defecto. Si creamos un dataset con <code><a class="el" href="classdataset.html#abb4cb5ac0f9a01fda7cd10e789c4dcf6">dataset.matrix</a></code> y el primer argumento es una matriz de tamaño $n_1  n_2    n_k$, podemos pasar un segundo argumento que es una tabla con los siguientes campos:</p>
<p>{description}</p>
<p>[patternSize] Es una tabla de $k$ enteros estrictamente positivos. Indica el tamaño del sub-patrón. Su valor por defecto es $ 1, n_2, n_3, {}, n_k </p>
</div></div><!-- contents -->

</BODY>
</HTML>
