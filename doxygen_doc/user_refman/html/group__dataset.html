<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<title>april-ann</title>
<link href="our_doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<div class="tabs"><ul>
<li id="current"><a href="../../user_refman/html/index.html"><span>april-ann (user reference manual)</span></a></li>
<li><a href="../../developer/html/index.html"><span>april-ann (developer manual)</span></a></li>
</ul></div>
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">Dataset</div>  </div>
<div class="ingroups"><a class="el" href="group__basics.html">Basics</a></div></div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Dataset:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__dataset.png" border="0" alt="" usemap="#group____dataset"/>
<map name="group____dataset" id="group____dataset">
<area shape="rect" id="node1" href="group__basics.html" title="Basics" alt="" coords="7,5,68,35"/></map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacedataset"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedataset.html">dataset</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdataset.html">dataset</a></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>


<h3><a class="anchor" id="dataset"></a>Dataset</h3><div class="textblock">Las matrices por sí mismas no son directamente utilizables desde los algoritmos de aprendizaje automático, ya que estos utilizan una abstracción de un conjunto de datos denominada <code>dataset</code> Un <code>dataset</code> responde a los métodos siguientes:<ul>
<li><b>numPatterns</b>, devuelve el número de patrones.</li>
</ul>
<ul>
<li><b>patternSize</b>, devuelve el tamaño máximo de los patrones.</li>
</ul>
<ul>
<li><b>getPattern</b>, recibe un índice numérico (un valor entre 1 y numPatterns) y devuelve un vector (tabla {Lua}) con el índice-ésimo patrón.</li>
</ul>
<ul>
<li><b>putPattern</b>, recibe un índice numérico (un valor entre 1 y {numPatterns}) y un vector de tamaño {patternSize} y modifica el {dataset} para dar cuenta de esta información. No todas las clases {dataset} permiten modificarse, y en tal caso avisan devolviendo 0 en lugar de {patternSize}. {itemize}</li>
</ul>
<h1><a class="anchor" id="dataset_matrix"></a>
dataset.matrix</h1>
<p>La forma más convencional de crear un <code>dataset</code> es a partir de una matriz: </p>
<pre class="fragment">--&gt; recordemos que xor_in es una matriz de 4x2
ds_xor_in = dataset.matrix(xor_in) --&gt; 4 patrones de tamaño 2
--&gt; recordemos que xor_out es una matriz de 4x1
ds_xor_out = dataset.matrix(xor_out) --&gt; 4 patrones de tamaño 1
</pre><p>Cuando creamos un dataset a partir de una matriz de dimensiones <img class="formulaInl" alt="$n_1 \times n_2 \times \cdots \times n_k$" src="form_5.png"/> se crea un dataset con <img class="formulaInl" alt="$n_1$" src="form_6.png"/> patrones de tamaño <img class="formulaInl" alt="$n_2 \cdots \times n_{k}$" src="form_7.png"/>. Para una matriz de dimensión 2 corresponde con lo esperado de manera intuitiva, mientras que para una matriz tiene una sola dimensión (un vector) se corresponde con el recorrido de todos sus valores, como se aprecia en el siguiente ejemplo, donde además vemos que el método <code>patterns()</code> devuelve un iterador que se puede utlizar en un bucle <code>for:</code> </p>
<pre class="fragment">a = matrix(2, 2, {1,2,3,4})
b = dataset.matrix(a)
for i,j in b:patterns() do print(table.concat(j,",")) end
--&gt; 1,2
--&gt; 3,4
a = matrix(2,2,2,{1,2,3,4,5,6,7,8})
b = dataset.matrix(a)
for i,j in b:patterns() do print(table.concat(j,",")) end
--&gt; 1,2,3,4
--&gt; 5,6,7,8
a = matrix(4,{1,2,3,4})
b = dataset.matrix(a)
for i,j in b:patterns() do print(table.concat(j,",")) end
--&gt; 1
--&gt; 2
--&gt; 3
--&gt; 4
</pre><p>Hasta aquí no se aprecia ninguna ventaja del uso de <code>dataset</code> respecto de las matrices. Vamos a ver que sobre una misma matriz podemos generar varios datasets variando algunos parámetros que, hasta el momento, se han tomado por defecto. Si creamos un dataset con <code><a class="el" href="classdataset.html#abb4cb5ac0f9a01fda7cd10e789c4dcf6">dataset.matrix</a></code> y el primer argumento es una matriz de tamaño <img class="formulaInl" alt="$n_1 \times n_2 \times \cdots \times n_k$" src="form_5.png"/>, podemos pasar un segundo argumento que es una tabla con los siguientes campos:</p>
<ul>
<li><b>patternSize</b>, Es una tabla de <img class="formulaInl" alt="$k$" src="form_8.png"/> enteros estrictamente positivos. Indica el tamaño del sub-patrón. Su valor por defecto es <img class="formulaInl" alt="$\{ 1, n_2, n_3, \ldots{}, n_k\}$" src="form_9.png"/>.</li>
</ul>
<ul>
<li><b>offset</b>, Es una tabla de <img class="formulaInl" alt="$k$" src="form_8.png"/> enteros. Indica la posición inicial del primer subpatrón que se va a extraer. Esta es una mejora respecto al {SNNS}, por ejemplo. Además, los valores pueden ser negativos o pueden salirse de las coordenadas límite de la matriz. Atención porque la posición inicial en una coordenada es 0 (como en C) y no 1 (como en {Lua}). El valor por defecto de este campo es <img class="formulaInl" alt="$\{0,\ldots{},0\}$" src="form_10.png"/>.</li>
</ul>
<ul>
<li><b>numSteps</b>, Es una tabla de <img class="formulaInl" alt="$k$" src="form_8.png"/> enteros estrictamente positivos. Indica el número de pasos que se utilizan en cada dimensión para generar todos los subpatrones. Su valor por defecto es <img class="formulaInl" alt="$\{n_1, 1, \ldots{}, 1\}$" src="form_11.png"/>. El número total de patrones del dataset será siempre igual al productorio de los valores de este campo.</li>
</ul>
<ul>
<li><p class="startli"><b>stepSize</b>, Es una tabla de <img class="formulaInl" alt="$k$" src="form_8.png"/> valores enteros, pueden ser negativos o incluso cero. Indica el número de coordenadas que avanzamos en cada dimensión cuando generamos los subpatrones. Su valor por defecto es <img class="formulaInl" alt="$\{1,\ldots{},1\}$" src="form_12.png"/>.</p>
<p class="startli">Evidentemente, en aquellas coordenadas donde <code>numSteps</code> sea 1, no se utiliza el valor correspondiente de <code>stepSize</code>, así que da igual el valor que le demos en esas coordenadas.</p>
<p class="startli">Existen muchas formas de recorrer una matriz, pero hay dos muy habituales denominadas modo {particionamiento} (denominado también teselación o <code>tiling'') y el modo \emph{desplazamiento} (o </code>shifting''). Para crear un dataset que recorra la matriz en modo particionamiento basta con poner el valor {stepSize} igual a {patternSize} en aquellas coordenadas donde {patternSize} sea inferior al número de elementos en esa dimensión, y poner 1 en las restantes.</p>
</li>
</ul>
<ul>
<li><b>orderStep</b>, Indica el orden en que se utilizan las <img class="formulaInl" alt="$k$" src="form_8.png"/> coordenadas de la matriz para recorrer todos los subpatrones que se van a generar. Su valor por defecto es <img class="formulaInl" alt="$k-1,k-2,\ldots{},2,1,0$" src="form_13.png"/> que corresponde a recorrer una matriz bidimensional por filas. Variando este campo se puede lograr un recorrido por columnas, por ejemplo.</li>
</ul>
<ul>
<li><b>defaultValue</b>, Es un valor numérico (no necesariamente entero) que se utiliza para rellenar un patrón en aquellas zonas que se salen de los límites de la matriz por cualquiera de sus extremos. Su valor por defecto es 0.</li>
</ul>
<ul>
<li><b>circular</b>, Es una tabla de <img class="formulaInl" alt="$k$" src="form_8.png"/> valores {booleanos} (en {Lua} existen los literales {true} y {false}) que indican, para cada coordenada de la matriz, si ésta es circular o no. Su valor por defecto es todo a {false} (es decir, no circular). Cuando una coordenada no es circular, al salirnos fuera de la matriz nos encontraremos con el valor por defecto {defaultValue}, mientras que si la coordenada sí es circular, en lugar de salirnos volveremos a la coordenada inicial. Por ejemplo, si creamos una matriz de dimensión 2 y hacemos circular una de las coordenadas, tendríamos algo similar a un cilindro sin tapas. Si hacemos las 2 coordenadas circulares tendríamos un toro (un donut).</li>
</ul>
<p>Veamos un ejemplo sencillo del uso de estos valores. Queremos generar los datasets para aprender la or exclusiva utilizando una sola matriz:</p>
<pre class="fragment">m_xor = matrix.fromString[[
4 3
ascii
0 0 0
0 1 1
1 0 1
1 1 0
]]
ds_input  = dataset.matrix(m_xor,{patternSize={1,2}})
ds_output = dataset.matrix(m_xor,{offset={0,2},patternSize={1,1}})
for i = 1,ds_input:numPatterns() do
  printf("Index %d -&gt; Input: %s Output: %s\n",i,
         table.concat(ds_input:getPattern(i),","),
         table.concat(ds_output:getPattern(i),","))
end
--[[ Salida:
Index 1 -&gt; Input: 0,0 Output: 0
Index 2 -&gt; Input: 0,1 Output: 1
Index 3 -&gt; Input: 1,0 Output: 1
Index 4 -&gt; Input: 1,1 Output: 0
]]--
</pre><p>Como esta forma de utilizar una matriz es tan general, podemos definir la siguiente funcion: </p>
<pre class="fragment">function dataset_pair(m,sizein,sizeout)
  local d_in  = dataset.matrix(m,{patternSize = {1,sizein}})
  local d_out = dataset.matrix(m,{offset={0,sizein},patternSize = {1,sizeout}})
  return d_in,d_out
end
-- se puede utilizar así:
ds_input,ds_output = dataset_pair(m_xor,2,1)
</pre><h1><a class="anchor" id="dataset_union"></a>
dataset.union</h1>
<p>Permite que varios datasets que tienen el mismo <code>patternSize</code> se vean como uno solo con un <code>numPatterns</code> igual al sumatorio de los <code>numPatterns</code> de los <code>datasets</code> que lo componen. Requiere un único argumento que es una tabla con los <code>datasets</code> necesarios.</p>
<h1><a class="anchor" id="dataset_indexed"></a>
dataset.indexed</h1>
<p>El formato indexado permite crear un mapping de indices a patterns. Puede ser útil para especificar la salida de una clasificación, en tal caso el <code>dataset</code> sobre el que se basa el <code><a class="el" href="classdataset.html#ad933fb01f7f7b1bfa4085695b394397b">dataset.indexed</a></code> representa la salida asociada a cada una de las clases.</p>
<p>Requiere 2 argumentos. El primero es el dataset base. El segundo es una tabla con tantos <code>datasets</code> como <code>patternSize</code> tenga el dataset base, cada uno de ellos actuará como diccionario. El <code>patternSize</code> del <code><a class="el" href="classdataset.html#ad933fb01f7f7b1bfa4085695b394397b">dataset.indexed</a></code> resultante es igual a la suma de los <code>patternSize</code> de cada diccionario.</p>
<h1><a class="anchor" id="dataset_slice"></a>
dataset.slice</h1>
<p>Permite seleccionar un subconjunto de patterns de un dataset, este subconjunto debe ser un intervalo (para subconjuntos más generales se puede utilizar la clase <code>dataset.index</code>) Requiere 3 argumentos. El primero es el dataset y luego necesita 2 argumentos que son los indices inicial y final de los patrones que se eligen como subconjunto.</p>
<h1><a class="anchor" id="dataset_split"></a>
dataset.split</h1>
<p>Permite seleccionar un subconjunto de los elementos de salida de un dataset. Es decir, el dataset resultante tiene el mismo numero de patrones (<code>numPatterns</code>) pero un <code>patternSize</code> menor. El subconjunto de salida es un intervalo del original.</p>
<h1><a class="anchor" id="dataset_linearcomb"></a>
dataset.linearcomb</h1>
<p>Permite realizar una combinación lineal de los elementos de un <code>dataset</code>. Se trata de una forma mucho más general que el <code><a class="el" href="classdataset.html#a8c39aa09ebee4f41218945f0763a28e8">dataset.split</a></code> anteriormente descrito puesto que, aunque de manera algo complicada, es posible simular un <code><a class="el" href="classdataset.html#a8c39aa09ebee4f41218945f0763a28e8">dataset.split</a></code> mediante un <code><a class="el" href="classdataset.html#af614112546a435785ff5ec8200fcde89">dataset.linearcomb</a></code>.</p>
<p>Un <code><a class="el" href="classdataset.html#af614112546a435785ff5ec8200fcde89">dataset.linearcomb</a></code> requiere dos argumentos: un <code>dataset</code> y una tabla. La tabla es un vector con tantas componentes como queramos que sea el <code>patternSize</code> del <code><a class="el" href="classdataset.html#af614112546a435785ff5ec8200fcde89">dataset.linearcomb</a></code> resultante. Obsérvese que el <code>numPatterns</code> del dataset resultante será el mismo.</p>
<p>Cada componente correspondiente a cada posición de los patrones generados por el <code><a class="el" href="classdataset.html#af614112546a435785ff5ec8200fcde89">dataset.linearcomb</a></code> es una combinación lineal expresada como una lista de pares (índice,valor). El índice <img class="formulaInl" alt="$0$" src="form_14.png"/> está reservado a la constante numérica <img class="formulaInl" alt="$1$" src="form_15.png"/>.</p>
<p>Veamos mediante un ejemplo cómo se utiliza. Tenemos un dataset de <img class="formulaInl" alt="$4$" src="form_16.png"/> patrones de tamaño <img class="formulaInl" alt="$4$" src="form_16.png"/>. Queremos generar otro dataset con <img class="formulaInl" alt="$4$" src="form_16.png"/> patrones de tamaño <img class="formulaInl" alt="$3$" src="form_17.png"/>, donde cada uno de los 3 elementos del patrón es una combinación lineal del dataset de partida. La primera componente es el <img class="formulaInl" alt="$1^{er}$" src="form_18.png"/> elemento del patrón original más dos veces el segundo elemento. La segunda componente es la constante numérica <img class="formulaInl" alt="$5$" src="form_19.png"/> más dos veces el tercer elemento del patrón original. Por último, la tercera componente es la segunda componente del patrón original:</p>
<pre class="fragment">-- creamos una matriz
m = matrix.fromString[[
4 4
ascii
 1  2  3  4
 4  5  6  8
 9 10 11 12
13 14 15 16
]]
d = dataset.matrix(m) - 4 patrones: cada fila de la matriz
linearc = { -- 3 combinaciones lineales:
  { {1,1.0}, {2, 2.0} },
  { {0,5.0} , {3, 2.0} }, -- 5.0 + 2*posicion_3 del patrón
  { {2,1.0} },
}
dlc = dataset.linearcomb(d,linearc)

print("dataset d:")
for index,pattern in d:patterns() do
  print(index,string.join(pattern,","))
end
print("dataset dlc:")
for index,pattern in dlc:patterns() do
  print(index,string.join(pattern,","))
end

--[[ La salida sería:
dataset d:
1       1,2,3,4
2       4,5,6,8
3       9,10,11,12
4       13,14,15,16
dataset dlc:
1       5,11,2
2       14,17,5
3       29,27,10
4       41,35,14
]]</pre><h1><a class="anchor" id="dataset_join"></a>
dataset.join</h1>
<p>Permite juntar las salidas de varios dataset que tienen el mismo numero de patrones (<code>numPatterns</code>). El <code>patternSize</code> del dataset resultante es igual al sumatorio de los <code>patternSize</code> de los datasets que lo componen. Requiere un único argumento que es una tabla con los datasets necesarios. </p>
</div></div><!-- contents -->

</BODY>
</HTML>
